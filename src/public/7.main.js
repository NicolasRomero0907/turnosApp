(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[7],{

/***/ "./node_modules/@firebase/remote-config/dist/index.cjs.js":
/*!****************************************************************!*\
  !*** ./node_modules/@firebase/remote-config/dist/index.cjs.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar firebase = _interopDefault(__webpack_require__(/*! @firebase/app */ \"./node_modules/@firebase/app/dist/index.cjs.js\"));\n__webpack_require__(/*! @firebase/installations */ \"./node_modules/@firebase/installations/dist/index.esm.js\");\nvar tslib = __webpack_require__(/*! tslib */ \"./node_modules/@firebase/remote-config/node_modules/tslib/tslib.es6.js\");\nvar util = __webpack_require__(/*! @firebase/util */ \"./node_modules/@firebase/util/dist/index.cjs.js\");\nvar logger = __webpack_require__(/*! @firebase/logger */ \"./node_modules/@firebase/logger/dist/index.esm.js\");\nvar component = __webpack_require__(/*! @firebase/component */ \"./node_modules/@firebase/component/dist/index.cjs.js\");\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Implements the {@link RemoteConfigClient} abstraction with success response caching.\r\n *\r\n * <p>Comparable to the browser's Cache API for responses, but the Cache API requires a Service\r\n * Worker, which requires HTTPS, which would significantly complicate SDK installation. Also, the\r\n * Cache API doesn't support matching entries by time.\r\n */\r\nvar CachingClient = /** @class */ (function () {\r\n    function CachingClient(client, storage, storageCache, logger) {\r\n        this.client = client;\r\n        this.storage = storage;\r\n        this.storageCache = storageCache;\r\n        this.logger = logger;\r\n    }\r\n    /**\r\n     * Returns true if the age of the cached fetched configs is less than or equal to\r\n     * {@link Settings#minimumFetchIntervalInSeconds}.\r\n     *\r\n     * <p>This is comparable to passing `headers = { 'Cache-Control': max-age <maxAge> }` to the\r\n     * native Fetch API.\r\n     *\r\n     * <p>Visible for testing.\r\n     */\r\n    CachingClient.prototype.isCachedDataFresh = function (cacheMaxAgeMillis, lastSuccessfulFetchTimestampMillis) {\r\n        // Cache can only be fresh if it's populated.\r\n        if (!lastSuccessfulFetchTimestampMillis) {\r\n            this.logger.debug('Config fetch cache check. Cache unpopulated.');\r\n            return false;\r\n        }\r\n        // Calculates age of cache entry.\r\n        var cacheAgeMillis = Date.now() - lastSuccessfulFetchTimestampMillis;\r\n        var isCachedDataFresh = cacheAgeMillis <= cacheMaxAgeMillis;\r\n        this.logger.debug('Config fetch cache check.' +\r\n            (\" Cache age millis: \" + cacheAgeMillis + \".\") +\r\n            (\" Cache max age millis (minimumFetchIntervalMillis setting): \" + cacheMaxAgeMillis + \".\") +\r\n            (\" Is cache hit: \" + isCachedDataFresh + \".\"));\r\n        return isCachedDataFresh;\r\n    };\r\n    CachingClient.prototype.fetch = function (request) {\r\n        return tslib.__awaiter(this, void 0, void 0, function () {\r\n            var _a, lastSuccessfulFetchTimestampMillis, lastSuccessfulFetchResponse, response, storageOperations;\r\n            return tslib.__generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0: return [4 /*yield*/, Promise.all([\r\n                            this.storage.getLastSuccessfulFetchTimestampMillis(),\r\n                            this.storage.getLastSuccessfulFetchResponse()\r\n                        ])];\r\n                    case 1:\r\n                        _a = _b.sent(), lastSuccessfulFetchTimestampMillis = _a[0], lastSuccessfulFetchResponse = _a[1];\r\n                        // Exits early on cache hit.\r\n                        if (lastSuccessfulFetchResponse &&\r\n                            this.isCachedDataFresh(request.cacheMaxAgeMillis, lastSuccessfulFetchTimestampMillis)) {\r\n                            return [2 /*return*/, lastSuccessfulFetchResponse];\r\n                        }\r\n                        // Deviates from pure decorator by not honoring a passed ETag since we don't have a public API\r\n                        // that allows the caller to pass an ETag.\r\n                        request.eTag =\r\n                            lastSuccessfulFetchResponse && lastSuccessfulFetchResponse.eTag;\r\n                        return [4 /*yield*/, this.client.fetch(request)];\r\n                    case 2:\r\n                        response = _b.sent();\r\n                        storageOperations = [\r\n                            // Uses write-through cache for consistency with synchronous public API.\r\n                            this.storageCache.setLastSuccessfulFetchTimestampMillis(Date.now())\r\n                        ];\r\n                        if (response.status === 200) {\r\n                            // Caches response only if it has changed, ie non-304 responses.\r\n                            storageOperations.push(this.storage.setLastSuccessfulFetchResponse(response));\r\n                        }\r\n                        return [4 /*yield*/, Promise.all(storageOperations)];\r\n                    case 3:\r\n                        _b.sent();\r\n                        return [2 /*return*/, response];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return CachingClient;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar _a;\r\nvar ERROR_DESCRIPTION_MAP = (_a = {},\r\n    _a[\"registration-window\" /* REGISTRATION_WINDOW */] = 'Undefined window object. This SDK only supports usage in a browser environment.',\r\n    _a[\"registration-project-id\" /* REGISTRATION_PROJECT_ID */] = 'Undefined project identifier. Check Firebase app initialization.',\r\n    _a[\"registration-api-key\" /* REGISTRATION_API_KEY */] = 'Undefined API key. Check Firebase app initialization.',\r\n    _a[\"registration-app-id\" /* REGISTRATION_APP_ID */] = 'Undefined app identifier. Check Firebase app initialization.',\r\n    _a[\"storage-open\" /* STORAGE_OPEN */] = 'Error thrown when opening storage. Original error: {$originalErrorMessage}.',\r\n    _a[\"storage-get\" /* STORAGE_GET */] = 'Error thrown when reading from storage. Original error: {$originalErrorMessage}.',\r\n    _a[\"storage-set\" /* STORAGE_SET */] = 'Error thrown when writing to storage. Original error: {$originalErrorMessage}.',\r\n    _a[\"storage-delete\" /* STORAGE_DELETE */] = 'Error thrown when deleting from storage. Original error: {$originalErrorMessage}.',\r\n    _a[\"fetch-client-network\" /* FETCH_NETWORK */] = 'Fetch client failed to connect to a network. Check Internet connection.' +\r\n        ' Original error: {$originalErrorMessage}.',\r\n    _a[\"fetch-timeout\" /* FETCH_TIMEOUT */] = 'The config fetch request timed out. ' +\r\n        ' Configure timeout using \"fetchTimeoutMillis\" SDK setting.',\r\n    _a[\"fetch-throttle\" /* FETCH_THROTTLE */] = 'The config fetch request timed out while in an exponential backoff state.' +\r\n        ' Configure timeout using \"fetchTimeoutMillis\" SDK setting.' +\r\n        ' Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.',\r\n    _a[\"fetch-client-parse\" /* FETCH_PARSE */] = 'Fetch client could not parse response.' +\r\n        ' Original error: {$originalErrorMessage}.',\r\n    _a[\"fetch-status\" /* FETCH_STATUS */] = 'Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.',\r\n    _a);\r\nvar ERROR_FACTORY = new util.ErrorFactory('remoteconfig' /* service */, 'Remote Config' /* service name */, ERROR_DESCRIPTION_MAP);\r\n// Note how this is like typeof/instanceof, but for ErrorCode.\r\nfunction hasErrorCode(e, errorCode) {\r\n    return e instanceof util.FirebaseError && e.code.indexOf(errorCode) !== -1;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Attempts to get the most accurate browser language setting.\r\n *\r\n * <p>Adapted from getUserLanguage in packages/auth/src/utils.js for TypeScript.\r\n *\r\n * <p>Defers default language specification to server logic for consistency.\r\n *\r\n * @param navigatorLanguage Enables tests to override read-only {@link NavigatorLanguage}.\r\n */\r\nfunction getUserLanguage(navigatorLanguage) {\r\n    if (navigatorLanguage === void 0) { navigatorLanguage = navigator; }\r\n    return (\r\n    // Most reliable, but only supported in Chrome/Firefox.\r\n    (navigatorLanguage.languages && navigatorLanguage.languages[0]) ||\r\n        // Supported in most browsers, but returns the language of the browser\r\n        // UI, not the language set in browser settings.\r\n        navigatorLanguage.language\r\n    // Polyfill otherwise.\r\n    );\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Implements the Client abstraction for the Remote Config REST API.\r\n */\r\nvar RestClient = /** @class */ (function () {\r\n    function RestClient(firebaseInstallations, sdkVersion, namespace, projectId, apiKey, appId) {\r\n        this.firebaseInstallations = firebaseInstallations;\r\n        this.sdkVersion = sdkVersion;\r\n        this.namespace = namespace;\r\n        this.projectId = projectId;\r\n        this.apiKey = apiKey;\r\n        this.appId = appId;\r\n    }\r\n    /**\r\n     * Fetches from the Remote Config REST API.\r\n     *\r\n     * @throws a {@link ErrorCode.FETCH_NETWORK} error if {@link GlobalFetch#fetch} can't\r\n     * connect to the network.\r\n     * @throws a {@link ErrorCode.FETCH_PARSE} error if {@link Response#json} can't parse the\r\n     * fetch response.\r\n     * @throws a {@link ErrorCode.FETCH_STATUS} error if the service returns an HTTP error status.\r\n     */\r\n    RestClient.prototype.fetch = function (request) {\r\n        return tslib.__awaiter(this, void 0, void 0, function () {\r\n            var _a, installationId, installationToken, urlBase, url, headers, requestBody, options, fetchPromise, timeoutPromise, response, originalError_1, errorCode, status, responseEtag, config, state, responseBody, originalError_2;\r\n            return tslib.__generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0: return [4 /*yield*/, Promise.all([\r\n                            this.firebaseInstallations.getId(),\r\n                            this.firebaseInstallations.getToken()\r\n                        ])];\r\n                    case 1:\r\n                        _a = _b.sent(), installationId = _a[0], installationToken = _a[1];\r\n                        urlBase = window.FIREBASE_REMOTE_CONFIG_URL_BASE ||\r\n                            'https://firebaseremoteconfig.googleapis.com';\r\n                        url = urlBase + \"/v1/projects/\" + this.projectId + \"/namespaces/\" + this.namespace + \":fetch?key=\" + this.apiKey;\r\n                        headers = {\r\n                            'Content-Type': 'application/json',\r\n                            'Content-Encoding': 'gzip',\r\n                            // Deviates from pure decorator by not passing max-age header since we don't currently have\r\n                            // service behavior using that header.\r\n                            'If-None-Match': request.eTag || '*'\r\n                        };\r\n                        requestBody = {\r\n                            /* eslint-disable camelcase */\r\n                            sdk_version: this.sdkVersion,\r\n                            app_instance_id: installationId,\r\n                            app_instance_id_token: installationToken,\r\n                            app_id: this.appId,\r\n                            language_code: getUserLanguage()\r\n                            /* eslint-enable camelcase */\r\n                        };\r\n                        options = {\r\n                            method: 'POST',\r\n                            headers: headers,\r\n                            body: JSON.stringify(requestBody)\r\n                        };\r\n                        fetchPromise = fetch(url, options);\r\n                        timeoutPromise = new Promise(function (_resolve, reject) {\r\n                            // Maps async event listener to Promise API.\r\n                            request.signal.addEventListener(function () {\r\n                                // Emulates https://heycam.github.io/webidl/#aborterror\r\n                                var error = new Error('The operation was aborted.');\r\n                                error.name = 'AbortError';\r\n                                reject(error);\r\n                            });\r\n                        });\r\n                        _b.label = 2;\r\n                    case 2:\r\n                        _b.trys.push([2, 5, , 6]);\r\n                        return [4 /*yield*/, Promise.race([fetchPromise, timeoutPromise])];\r\n                    case 3:\r\n                        _b.sent();\r\n                        return [4 /*yield*/, fetchPromise];\r\n                    case 4:\r\n                        response = _b.sent();\r\n                        return [3 /*break*/, 6];\r\n                    case 5:\r\n                        originalError_1 = _b.sent();\r\n                        errorCode = \"fetch-client-network\" /* FETCH_NETWORK */;\r\n                        if (originalError_1.name === 'AbortError') {\r\n                            errorCode = \"fetch-timeout\" /* FETCH_TIMEOUT */;\r\n                        }\r\n                        throw ERROR_FACTORY.create(errorCode, {\r\n                            originalErrorMessage: originalError_1.message\r\n                        });\r\n                    case 6:\r\n                        status = response.status;\r\n                        responseEtag = response.headers.get('ETag') || undefined;\r\n                        if (!(response.status === 200)) return [3 /*break*/, 11];\r\n                        responseBody = void 0;\r\n                        _b.label = 7;\r\n                    case 7:\r\n                        _b.trys.push([7, 9, , 10]);\r\n                        return [4 /*yield*/, response.json()];\r\n                    case 8:\r\n                        responseBody = _b.sent();\r\n                        return [3 /*break*/, 10];\r\n                    case 9:\r\n                        originalError_2 = _b.sent();\r\n                        throw ERROR_FACTORY.create(\"fetch-client-parse\" /* FETCH_PARSE */, {\r\n                            originalErrorMessage: originalError_2.message\r\n                        });\r\n                    case 10:\r\n                        config = responseBody['entries'];\r\n                        state = responseBody['state'];\r\n                        _b.label = 11;\r\n                    case 11:\r\n                        // Normalizes based on legacy state.\r\n                        if (state === 'INSTANCE_STATE_UNSPECIFIED') {\r\n                            status = 500;\r\n                        }\r\n                        else if (state === 'NO_CHANGE') {\r\n                            status = 304;\r\n                        }\r\n                        else if (state === 'NO_TEMPLATE' || state === 'EMPTY_CONFIG') {\r\n                            // These cases can be fixed remotely, so normalize to safe value.\r\n                            config = {};\r\n                        }\r\n                        // Normalize to exception-based control flow for non-success cases.\r\n                        // Encapsulates HTTP specifics in this class as much as possible. Status is still the best for\r\n                        // differentiating success states (200 from 304; the state body param is undefined in a\r\n                        // standard 304).\r\n                        if (status !== 304 && status !== 200) {\r\n                            throw ERROR_FACTORY.create(\"fetch-status\" /* FETCH_STATUS */, {\r\n                                httpStatus: status\r\n                            });\r\n                        }\r\n                        return [2 /*return*/, { status: status, eTag: responseEtag, config: config }];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return RestClient;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Shims a minimal AbortSignal.\r\n *\r\n * <p>AbortController's AbortSignal conveniently decouples fetch timeout logic from other aspects\r\n * of networking, such as retries. Firebase doesn't use AbortController enough to justify a\r\n * polyfill recommendation, like we do with the Fetch API, but this minimal shim can easily be\r\n * swapped out if/when we do.\r\n */\r\nvar RemoteConfigAbortSignal = /** @class */ (function () {\r\n    function RemoteConfigAbortSignal() {\r\n        this.listeners = [];\r\n    }\r\n    RemoteConfigAbortSignal.prototype.addEventListener = function (listener) {\r\n        this.listeners.push(listener);\r\n    };\r\n    RemoteConfigAbortSignal.prototype.abort = function () {\r\n        this.listeners.forEach(function (listener) { return listener(); });\r\n    };\r\n    return RemoteConfigAbortSignal;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar DEFAULT_VALUE_FOR_BOOLEAN = false;\r\nvar DEFAULT_VALUE_FOR_STRING = '';\r\nvar DEFAULT_VALUE_FOR_NUMBER = 0;\r\nvar BOOLEAN_TRUTHY_VALUES = ['1', 'true', 't', 'yes', 'y', 'on'];\r\nvar Value = /** @class */ (function () {\r\n    function Value(_source, _value) {\r\n        if (_value === void 0) { _value = DEFAULT_VALUE_FOR_STRING; }\r\n        this._source = _source;\r\n        this._value = _value;\r\n    }\r\n    Value.prototype.asString = function () {\r\n        return this._value;\r\n    };\r\n    Value.prototype.asBoolean = function () {\r\n        if (this._source === 'static') {\r\n            return DEFAULT_VALUE_FOR_BOOLEAN;\r\n        }\r\n        return BOOLEAN_TRUTHY_VALUES.indexOf(this._value.toLowerCase()) >= 0;\r\n    };\r\n    Value.prototype.asNumber = function () {\r\n        if (this._source === 'static') {\r\n            return DEFAULT_VALUE_FOR_NUMBER;\r\n        }\r\n        var num = Number(this._value);\r\n        if (isNaN(num)) {\r\n            num = DEFAULT_VALUE_FOR_NUMBER;\r\n        }\r\n        return num;\r\n    };\r\n    Value.prototype.getSource = function () {\r\n        return this._source;\r\n    };\r\n    return Value;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar DEFAULT_FETCH_TIMEOUT_MILLIS = 60 * 1000; // One minute\r\nvar DEFAULT_CACHE_MAX_AGE_MILLIS = 12 * 60 * 60 * 1000; // Twelve hours.\r\n/**\r\n * Encapsulates business logic mapping network and storage dependencies to the public SDK API.\r\n *\r\n * See {@link https://github.com/FirebasePrivate/firebase-js-sdk/blob/master/packages/firebase/index.d.ts|interface documentation} for method descriptions.\r\n */\r\nvar RemoteConfig = /** @class */ (function () {\r\n    function RemoteConfig(\r\n    // Required by FirebaseServiceFactory interface.\r\n    app, \r\n    // JS doesn't support private yet\r\n    // (https://github.com/tc39/proposal-class-fields#private-fields), so we hint using an\r\n    // underscore prefix.\r\n    _client, _storageCache, _storage, _logger) {\r\n        this.app = app;\r\n        this._client = _client;\r\n        this._storageCache = _storageCache;\r\n        this._storage = _storage;\r\n        this._logger = _logger;\r\n        // Tracks completion of initialization promise.\r\n        this._isInitializationComplete = false;\r\n        this.settings = {\r\n            fetchTimeoutMillis: DEFAULT_FETCH_TIMEOUT_MILLIS,\r\n            minimumFetchIntervalMillis: DEFAULT_CACHE_MAX_AGE_MILLIS\r\n        };\r\n        this.defaultConfig = {};\r\n    }\r\n    // Based on packages/firestore/src/util/log.ts but not static because we need per-instance levels\r\n    // to differentiate 2p and 3p use-cases.\r\n    RemoteConfig.prototype.setLogLevel = function (logLevel) {\r\n        switch (logLevel) {\r\n            case 'debug':\r\n                this._logger.logLevel = logger.LogLevel.DEBUG;\r\n                break;\r\n            case 'silent':\r\n                this._logger.logLevel = logger.LogLevel.SILENT;\r\n                break;\r\n            default:\r\n                this._logger.logLevel = logger.LogLevel.ERROR;\r\n        }\r\n    };\r\n    Object.defineProperty(RemoteConfig.prototype, \"fetchTimeMillis\", {\r\n        get: function () {\r\n            return this._storageCache.getLastSuccessfulFetchTimestampMillis() || -1;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(RemoteConfig.prototype, \"lastFetchStatus\", {\r\n        get: function () {\r\n            return this._storageCache.getLastFetchStatus() || 'no-fetch-yet';\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    RemoteConfig.prototype.activate = function () {\r\n        return tslib.__awaiter(this, void 0, void 0, function () {\r\n            var _a, lastSuccessfulFetchResponse, activeConfigEtag;\r\n            return tslib.__generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0: return [4 /*yield*/, Promise.all([\r\n                            this._storage.getLastSuccessfulFetchResponse(),\r\n                            this._storage.getActiveConfigEtag()\r\n                        ])];\r\n                    case 1:\r\n                        _a = _b.sent(), lastSuccessfulFetchResponse = _a[0], activeConfigEtag = _a[1];\r\n                        if (!lastSuccessfulFetchResponse ||\r\n                            !lastSuccessfulFetchResponse.config ||\r\n                            !lastSuccessfulFetchResponse.eTag ||\r\n                            lastSuccessfulFetchResponse.eTag === activeConfigEtag) {\r\n                            // Either there is no successful fetched config, or is the same as current active\r\n                            // config.\r\n                            return [2 /*return*/, false];\r\n                        }\r\n                        return [4 /*yield*/, Promise.all([\r\n                                this._storageCache.setActiveConfig(lastSuccessfulFetchResponse.config),\r\n                                this._storage.setActiveConfigEtag(lastSuccessfulFetchResponse.eTag)\r\n                            ])];\r\n                    case 2:\r\n                        _b.sent();\r\n                        return [2 /*return*/, true];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    RemoteConfig.prototype.ensureInitialized = function () {\r\n        var _this = this;\r\n        if (!this._initializePromise) {\r\n            this._initializePromise = this._storageCache\r\n                .loadFromStorage()\r\n                .then(function () {\r\n                _this._isInitializationComplete = true;\r\n            });\r\n        }\r\n        return this._initializePromise;\r\n    };\r\n    /**\r\n     * @throws a {@link ErrorCode.FETCH_CLIENT_TIMEOUT} if the request takes longer than\r\n     * {@link Settings.fetchTimeoutInSeconds} or\r\n     * {@link DEFAULT_FETCH_TIMEOUT_SECONDS}.\r\n     */\r\n    RemoteConfig.prototype.fetch = function () {\r\n        return tslib.__awaiter(this, void 0, void 0, function () {\r\n            var abortSignal, e_1, lastFetchStatus;\r\n            var _this = this;\r\n            return tslib.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        abortSignal = new RemoteConfigAbortSignal();\r\n                        setTimeout(function () { return tslib.__awaiter(_this, void 0, void 0, function () {\r\n                            return tslib.__generator(this, function (_a) {\r\n                                // Note a very low delay, eg < 10ms, can elapse before listeners are initialized.\r\n                                abortSignal.abort();\r\n                                return [2 /*return*/];\r\n                            });\r\n                        }); }, this.settings.fetchTimeoutMillis);\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 4, , 6]);\r\n                        return [4 /*yield*/, this._client.fetch({\r\n                                cacheMaxAgeMillis: this.settings.minimumFetchIntervalMillis,\r\n                                signal: abortSignal\r\n                            })];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [4 /*yield*/, this._storageCache.setLastFetchStatus('success')];\r\n                    case 3:\r\n                        _a.sent();\r\n                        return [3 /*break*/, 6];\r\n                    case 4:\r\n                        e_1 = _a.sent();\r\n                        lastFetchStatus = hasErrorCode(e_1, \"fetch-throttle\" /* FETCH_THROTTLE */)\r\n                            ? 'throttle'\r\n                            : 'failure';\r\n                        return [4 /*yield*/, this._storageCache.setLastFetchStatus(lastFetchStatus)];\r\n                    case 5:\r\n                        _a.sent();\r\n                        throw e_1;\r\n                    case 6: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    RemoteConfig.prototype.fetchAndActivate = function () {\r\n        return tslib.__awaiter(this, void 0, void 0, function () {\r\n            return tslib.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.fetch()];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/, this.activate()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    RemoteConfig.prototype.getAll = function () {\r\n        var _this = this;\r\n        return getAllKeys(this._storageCache.getActiveConfig(), this.defaultConfig).reduce(function (allConfigs, key) {\r\n            allConfigs[key] = _this.getValue(key);\r\n            return allConfigs;\r\n        }, {});\r\n    };\r\n    RemoteConfig.prototype.getBoolean = function (key) {\r\n        return this.getValue(key).asBoolean();\r\n    };\r\n    RemoteConfig.prototype.getNumber = function (key) {\r\n        return this.getValue(key).asNumber();\r\n    };\r\n    RemoteConfig.prototype.getString = function (key) {\r\n        return this.getValue(key).asString();\r\n    };\r\n    RemoteConfig.prototype.getValue = function (key) {\r\n        if (!this._isInitializationComplete) {\r\n            this._logger.debug(\"A value was requested for key \\\"\" + key + \"\\\" before SDK initialization completed.\" +\r\n                ' Await on ensureInitialized if the intent was to get a previously activated value.');\r\n        }\r\n        var activeConfig = this._storageCache.getActiveConfig();\r\n        if (activeConfig && activeConfig[key] !== undefined) {\r\n            return new Value('remote', activeConfig[key]);\r\n        }\r\n        else if (this.defaultConfig && this.defaultConfig[key] !== undefined) {\r\n            return new Value('default', String(this.defaultConfig[key]));\r\n        }\r\n        this._logger.debug(\"Returning static value for key \\\"\" + key + \"\\\".\" +\r\n            ' Define a default or remote value if this is unintentional.');\r\n        return new Value('static');\r\n    };\r\n    return RemoteConfig;\r\n}());\r\n/**\r\n * Dedupes and returns an array of all the keys of the received objects.\r\n */\r\nfunction getAllKeys(obj1, obj2) {\r\n    if (obj1 === void 0) { obj1 = {}; }\r\n    if (obj2 === void 0) { obj2 = {}; }\r\n    return Object.keys(tslib.__assign(tslib.__assign({}, obj1), obj2));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Converts an error event associated with a {@link IDBRequest} to a {@link FirebaseError}.\r\n */\r\nfunction toFirebaseError(event, errorCode) {\r\n    var originalError = event.target.error || undefined;\r\n    return ERROR_FACTORY.create(errorCode, {\r\n        originalErrorMessage: originalError && originalError.message\r\n    });\r\n}\r\n/**\r\n * A general-purpose store keyed by app + namespace + {@link\r\n * ProjectNamespaceKeyFieldValue}.\r\n *\r\n * <p>The Remote Config SDK can be used with multiple app installations, and each app can interact\r\n * with multiple namespaces, so this store uses app (ID + name) and namespace as common parent keys\r\n * for a set of key-value pairs. See {@link Storage#createCompositeKey}.\r\n *\r\n * <p>Visible for testing.\r\n */\r\nvar APP_NAMESPACE_STORE = 'app_namespace_store';\r\nvar DB_NAME = 'firebase_remote_config';\r\nvar DB_VERSION = 1;\r\n// Visible for testing.\r\nfunction openDatabase() {\r\n    return new Promise(function (resolve, reject) {\r\n        var request = indexedDB.open(DB_NAME, DB_VERSION);\r\n        request.onerror = function (event) {\r\n            reject(toFirebaseError(event, \"storage-open\" /* STORAGE_OPEN */));\r\n        };\r\n        request.onsuccess = function (event) {\r\n            resolve(event.target.result);\r\n        };\r\n        request.onupgradeneeded = function (event) {\r\n            var db = event.target.result;\r\n            // We don't use 'break' in this switch statement, the fall-through\r\n            // behavior is what we want, because if there are multiple versions between\r\n            // the old version and the current version, we want ALL the migrations\r\n            // that correspond to those versions to run, not only the last one.\r\n            // eslint-disable-next-line default-case\r\n            switch (event.oldVersion) {\r\n                case 0:\r\n                    db.createObjectStore(APP_NAMESPACE_STORE, {\r\n                        keyPath: 'compositeKey'\r\n                    });\r\n            }\r\n        };\r\n    });\r\n}\r\n/**\r\n * Abstracts data persistence.\r\n */\r\nvar Storage = /** @class */ (function () {\r\n    /**\r\n     * @param appId enables storage segmentation by app (ID + name).\r\n     * @param appName enables storage segmentation by app (ID + name).\r\n     * @param namespace enables storage segmentation by namespace.\r\n     */\r\n    function Storage(appId, appName, namespace, openDbPromise) {\r\n        if (openDbPromise === void 0) { openDbPromise = openDatabase(); }\r\n        this.appId = appId;\r\n        this.appName = appName;\r\n        this.namespace = namespace;\r\n        this.openDbPromise = openDbPromise;\r\n    }\r\n    Storage.prototype.getLastFetchStatus = function () {\r\n        return this.get('last_fetch_status');\r\n    };\r\n    Storage.prototype.setLastFetchStatus = function (status) {\r\n        return this.set('last_fetch_status', status);\r\n    };\r\n    // This is comparable to a cache entry timestamp. If we need to expire other data, we could\r\n    // consider adding timestamp to all storage records and an optional max age arg to getters.\r\n    Storage.prototype.getLastSuccessfulFetchTimestampMillis = function () {\r\n        return this.get('last_successful_fetch_timestamp_millis');\r\n    };\r\n    Storage.prototype.setLastSuccessfulFetchTimestampMillis = function (timestamp) {\r\n        return this.set('last_successful_fetch_timestamp_millis', timestamp);\r\n    };\r\n    Storage.prototype.getLastSuccessfulFetchResponse = function () {\r\n        return this.get('last_successful_fetch_response');\r\n    };\r\n    Storage.prototype.setLastSuccessfulFetchResponse = function (response) {\r\n        return this.set('last_successful_fetch_response', response);\r\n    };\r\n    Storage.prototype.getActiveConfig = function () {\r\n        return this.get('active_config');\r\n    };\r\n    Storage.prototype.setActiveConfig = function (config) {\r\n        return this.set('active_config', config);\r\n    };\r\n    Storage.prototype.getActiveConfigEtag = function () {\r\n        return this.get('active_config_etag');\r\n    };\r\n    Storage.prototype.setActiveConfigEtag = function (etag) {\r\n        return this.set('active_config_etag', etag);\r\n    };\r\n    Storage.prototype.getThrottleMetadata = function () {\r\n        return this.get('throttle_metadata');\r\n    };\r\n    Storage.prototype.setThrottleMetadata = function (metadata) {\r\n        return this.set('throttle_metadata', metadata);\r\n    };\r\n    Storage.prototype.deleteThrottleMetadata = function () {\r\n        return this.delete('throttle_metadata');\r\n    };\r\n    Storage.prototype.get = function (key) {\r\n        return tslib.__awaiter(this, void 0, void 0, function () {\r\n            var db;\r\n            var _this = this;\r\n            return tslib.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.openDbPromise];\r\n                    case 1:\r\n                        db = _a.sent();\r\n                        return [2 /*return*/, new Promise(function (resolve, reject) {\r\n                                var transaction = db.transaction([APP_NAMESPACE_STORE], 'readonly');\r\n                                var objectStore = transaction.objectStore(APP_NAMESPACE_STORE);\r\n                                var compositeKey = _this.createCompositeKey(key);\r\n                                try {\r\n                                    var request = objectStore.get(compositeKey);\r\n                                    request.onerror = function (event) {\r\n                                        reject(toFirebaseError(event, \"storage-get\" /* STORAGE_GET */));\r\n                                    };\r\n                                    request.onsuccess = function (event) {\r\n                                        var result = event.target.result;\r\n                                        if (result) {\r\n                                            resolve(result.value);\r\n                                        }\r\n                                        else {\r\n                                            resolve(undefined);\r\n                                        }\r\n                                    };\r\n                                }\r\n                                catch (e) {\r\n                                    reject(ERROR_FACTORY.create(\"storage-get\" /* STORAGE_GET */, {\r\n                                        originalErrorMessage: e && e.message\r\n                                    }));\r\n                                }\r\n                            })];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Storage.prototype.set = function (key, value) {\r\n        return tslib.__awaiter(this, void 0, void 0, function () {\r\n            var db;\r\n            var _this = this;\r\n            return tslib.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.openDbPromise];\r\n                    case 1:\r\n                        db = _a.sent();\r\n                        return [2 /*return*/, new Promise(function (resolve, reject) {\r\n                                var transaction = db.transaction([APP_NAMESPACE_STORE], 'readwrite');\r\n                                var objectStore = transaction.objectStore(APP_NAMESPACE_STORE);\r\n                                var compositeKey = _this.createCompositeKey(key);\r\n                                try {\r\n                                    var request = objectStore.put({\r\n                                        compositeKey: compositeKey,\r\n                                        value: value\r\n                                    });\r\n                                    request.onerror = function (event) {\r\n                                        reject(toFirebaseError(event, \"storage-set\" /* STORAGE_SET */));\r\n                                    };\r\n                                    request.onsuccess = function () {\r\n                                        resolve();\r\n                                    };\r\n                                }\r\n                                catch (e) {\r\n                                    reject(ERROR_FACTORY.create(\"storage-set\" /* STORAGE_SET */, {\r\n                                        originalErrorMessage: e && e.message\r\n                                    }));\r\n                                }\r\n                            })];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Storage.prototype.delete = function (key) {\r\n        return tslib.__awaiter(this, void 0, void 0, function () {\r\n            var db;\r\n            var _this = this;\r\n            return tslib.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.openDbPromise];\r\n                    case 1:\r\n                        db = _a.sent();\r\n                        return [2 /*return*/, new Promise(function (resolve, reject) {\r\n                                var transaction = db.transaction([APP_NAMESPACE_STORE], 'readwrite');\r\n                                var objectStore = transaction.objectStore(APP_NAMESPACE_STORE);\r\n                                var compositeKey = _this.createCompositeKey(key);\r\n                                try {\r\n                                    var request = objectStore.delete(compositeKey);\r\n                                    request.onerror = function (event) {\r\n                                        reject(toFirebaseError(event, \"storage-delete\" /* STORAGE_DELETE */));\r\n                                    };\r\n                                    request.onsuccess = function () {\r\n                                        resolve();\r\n                                    };\r\n                                }\r\n                                catch (e) {\r\n                                    reject(ERROR_FACTORY.create(\"storage-delete\" /* STORAGE_DELETE */, {\r\n                                        originalErrorMessage: e && e.message\r\n                                    }));\r\n                                }\r\n                            })];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    // Facilitates composite key functionality (which is unsupported in IE).\r\n    Storage.prototype.createCompositeKey = function (key) {\r\n        return [this.appId, this.appName, this.namespace, key].join();\r\n    };\r\n    return Storage;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A memory cache layer over storage to support the SDK's synchronous read requirements.\r\n */\r\nvar StorageCache = /** @class */ (function () {\r\n    function StorageCache(storage) {\r\n        this.storage = storage;\r\n    }\r\n    /**\r\n     * Memory-only getters\r\n     */\r\n    StorageCache.prototype.getLastFetchStatus = function () {\r\n        return this.lastFetchStatus;\r\n    };\r\n    StorageCache.prototype.getLastSuccessfulFetchTimestampMillis = function () {\r\n        return this.lastSuccessfulFetchTimestampMillis;\r\n    };\r\n    StorageCache.prototype.getActiveConfig = function () {\r\n        return this.activeConfig;\r\n    };\r\n    /**\r\n     * Read-ahead getter\r\n     */\r\n    StorageCache.prototype.loadFromStorage = function () {\r\n        return tslib.__awaiter(this, void 0, void 0, function () {\r\n            var lastFetchStatusPromise, lastSuccessfulFetchTimestampMillisPromise, activeConfigPromise, lastFetchStatus, lastSuccessfulFetchTimestampMillis, activeConfig;\r\n            return tslib.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        lastFetchStatusPromise = this.storage.getLastFetchStatus();\r\n                        lastSuccessfulFetchTimestampMillisPromise = this.storage.getLastSuccessfulFetchTimestampMillis();\r\n                        activeConfigPromise = this.storage.getActiveConfig();\r\n                        return [4 /*yield*/, lastFetchStatusPromise];\r\n                    case 1:\r\n                        lastFetchStatus = _a.sent();\r\n                        if (lastFetchStatus) {\r\n                            this.lastFetchStatus = lastFetchStatus;\r\n                        }\r\n                        return [4 /*yield*/, lastSuccessfulFetchTimestampMillisPromise];\r\n                    case 2:\r\n                        lastSuccessfulFetchTimestampMillis = _a.sent();\r\n                        if (lastSuccessfulFetchTimestampMillis) {\r\n                            this.lastSuccessfulFetchTimestampMillis = lastSuccessfulFetchTimestampMillis;\r\n                        }\r\n                        return [4 /*yield*/, activeConfigPromise];\r\n                    case 3:\r\n                        activeConfig = _a.sent();\r\n                        if (activeConfig) {\r\n                            this.activeConfig = activeConfig;\r\n                        }\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Write-through setters\r\n     */\r\n    StorageCache.prototype.setLastFetchStatus = function (status) {\r\n        this.lastFetchStatus = status;\r\n        return this.storage.setLastFetchStatus(status);\r\n    };\r\n    StorageCache.prototype.setLastSuccessfulFetchTimestampMillis = function (timestampMillis) {\r\n        this.lastSuccessfulFetchTimestampMillis = timestampMillis;\r\n        return this.storage.setLastSuccessfulFetchTimestampMillis(timestampMillis);\r\n    };\r\n    StorageCache.prototype.setActiveConfig = function (activeConfig) {\r\n        this.activeConfig = activeConfig;\r\n        return this.storage.setActiveConfig(activeConfig);\r\n    };\r\n    return StorageCache;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The amount of milliseconds to exponentially increase.\r\n */\r\nvar INTERVAL_MILLIS = 1000;\r\n/**\r\n * The factor to backoff by.\r\n * Should be a number greater than 1.\r\n */\r\nvar BACKOFF_FACTOR = 2;\r\n/**\r\n * The maximum milliseconds to increase to.\r\n *\r\n * <p>Visible for testing\r\n */\r\nvar MAX_VALUE_MILLIS = 4 * 60 * 60 * 1000; // Four hours, like iOS and Android.\r\n/**\r\n * The percentage of backoff time to randomize by.\r\n * See\r\n * http://go/safe-client-behavior#step-1-determine-the-appropriate-retry-interval-to-handle-spike-traffic\r\n * for context.\r\n *\r\n * <p>Visible for testing\r\n */\r\nvar RANDOM_FACTOR = 0.5;\r\n/**\r\n * Based on the backoff method from\r\n * https://github.com/google/closure-library/blob/master/closure/goog/math/exponentialbackoff.js.\r\n * Extracted here so we don't need to pass metadata and a stateful ExponentialBackoff object around.\r\n */\r\nfunction calculateBackoffMillis(backoffCount) {\r\n    // Calculates an exponentially increasing value.\r\n    // Deviation: calculates value from count and a constant interval, so we only need to save value\r\n    // and count to restore state.\r\n    var currBaseValue = INTERVAL_MILLIS * Math.pow(BACKOFF_FACTOR, backoffCount);\r\n    // A random \"fuzz\" to avoid waves of retries.\r\n    // Deviation: randomFactor is required.\r\n    var randomWait = Math.round(\r\n    // A fraction of the backoff value to add/subtract.\r\n    // Deviation: changes multiplication order to improve readability.\r\n    RANDOM_FACTOR *\r\n        currBaseValue *\r\n        // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines\r\n        // if we add or subtract.\r\n        (Math.random() - 0.5) *\r\n        2);\r\n    // Limits backoff to max to avoid effectively permanent backoff.\r\n    return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Supports waiting on a backoff by:\r\n *\r\n * <ul>\r\n *   <li>Promisifying setTimeout, so we can set a timeout in our Promise chain</li>\r\n *   <li>Listening on a signal bus for abort events, just like the Fetch API</li>\r\n *   <li>Failing in the same way the Fetch API fails, so timing out a live request and a throttled\r\n *       request appear the same.</li>\r\n * </ul>\r\n *\r\n * <p>Visible for testing.\r\n */\r\nfunction setAbortableTimeout(signal, throttleEndTimeMillis) {\r\n    return new Promise(function (resolve, reject) {\r\n        // Derives backoff from given end time, normalizing negative numbers to zero.\r\n        var backoffMillis = Math.max(throttleEndTimeMillis - Date.now(), 0);\r\n        var timeout = setTimeout(resolve, backoffMillis);\r\n        // Adds listener, rather than sets onabort, because signal is a shared object.\r\n        signal.addEventListener(function () {\r\n            clearTimeout(timeout);\r\n            // If the request completes before this timeout, the rejection has no effect.\r\n            reject(ERROR_FACTORY.create(\"fetch-throttle\" /* FETCH_THROTTLE */, {\r\n                throttleEndTimeMillis: throttleEndTimeMillis\r\n            }));\r\n        });\r\n    });\r\n}\r\n/**\r\n * Returns true if the {@link Error} indicates a fetch request may succeed later.\r\n */\r\nfunction isRetriableError(e) {\r\n    if (!(e instanceof util.FirebaseError)) {\r\n        return false;\r\n    }\r\n    // Uses string index defined by ErrorData, which FirebaseError implements.\r\n    var httpStatus = Number(e['httpStatus']);\r\n    return (httpStatus === 429 ||\r\n        httpStatus === 500 ||\r\n        httpStatus === 503 ||\r\n        httpStatus === 504);\r\n}\r\n/**\r\n * Decorates a Client with retry logic.\r\n *\r\n * <p>Comparable to CachingClient, but uses backoff logic instead of cache max age and doesn't cache\r\n * responses (because the SDK has no use for error responses).\r\n */\r\nvar RetryingClient = /** @class */ (function () {\r\n    function RetryingClient(client, storage) {\r\n        this.client = client;\r\n        this.storage = storage;\r\n    }\r\n    RetryingClient.prototype.fetch = function (request) {\r\n        return tslib.__awaiter(this, void 0, void 0, function () {\r\n            var throttleMetadata;\r\n            return tslib.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.storage.getThrottleMetadata()];\r\n                    case 1:\r\n                        throttleMetadata = (_a.sent()) || {\r\n                            backoffCount: 0,\r\n                            throttleEndTimeMillis: Date.now()\r\n                        };\r\n                        return [2 /*return*/, this.attemptFetch(request, throttleMetadata)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * A recursive helper for attempting a fetch request repeatedly.\r\n     *\r\n     * @throws any non-retriable errors.\r\n     */\r\n    RetryingClient.prototype.attemptFetch = function (request, _a) {\r\n        var throttleEndTimeMillis = _a.throttleEndTimeMillis, backoffCount = _a.backoffCount;\r\n        return tslib.__awaiter(this, void 0, void 0, function () {\r\n            var response, e_1, throttleMetadata;\r\n            return tslib.__generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0: \r\n                    // Starts with a (potentially zero) timeout to support resumption from stored state.\r\n                    // Ensures the throttle end time is honored if the last attempt timed out.\r\n                    // Note the SDK will never make a request if the fetch timeout expires at this point.\r\n                    return [4 /*yield*/, setAbortableTimeout(request.signal, throttleEndTimeMillis)];\r\n                    case 1:\r\n                        // Starts with a (potentially zero) timeout to support resumption from stored state.\r\n                        // Ensures the throttle end time is honored if the last attempt timed out.\r\n                        // Note the SDK will never make a request if the fetch timeout expires at this point.\r\n                        _b.sent();\r\n                        _b.label = 2;\r\n                    case 2:\r\n                        _b.trys.push([2, 5, , 7]);\r\n                        return [4 /*yield*/, this.client.fetch(request)];\r\n                    case 3:\r\n                        response = _b.sent();\r\n                        // Note the SDK only clears throttle state if response is success or non-retriable.\r\n                        return [4 /*yield*/, this.storage.deleteThrottleMetadata()];\r\n                    case 4:\r\n                        // Note the SDK only clears throttle state if response is success or non-retriable.\r\n                        _b.sent();\r\n                        return [2 /*return*/, response];\r\n                    case 5:\r\n                        e_1 = _b.sent();\r\n                        if (!isRetriableError(e_1)) {\r\n                            throw e_1;\r\n                        }\r\n                        throttleMetadata = {\r\n                            throttleEndTimeMillis: Date.now() + calculateBackoffMillis(backoffCount),\r\n                            backoffCount: backoffCount + 1\r\n                        };\r\n                        // Persists state.\r\n                        return [4 /*yield*/, this.storage.setThrottleMetadata(throttleMetadata)];\r\n                    case 6:\r\n                        // Persists state.\r\n                        _b.sent();\r\n                        return [2 /*return*/, this.attemptFetch(request, throttleMetadata)];\r\n                    case 7: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return RetryingClient;\r\n}());\n\nvar name = \"@firebase/remote-config\";\nvar version = \"0.1.22\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction registerRemoteConfig(firebaseInstance) {\r\n    firebaseInstance.INTERNAL.registerComponent(new component.Component('remoteConfig', remoteConfigFactory, \"PUBLIC\" /* PUBLIC */).setMultipleInstances(true));\r\n    firebaseInstance.registerVersion(name, version);\r\n    function remoteConfigFactory(container, namespace) {\r\n        /* Dependencies */\r\n        // getImmediate for FirebaseApp will always succeed\r\n        var app = container.getProvider('app').getImmediate();\r\n        // The following call will always succeed because rc has `import '@firebase/installations'`\r\n        var installations = container.getProvider('installations').getImmediate();\r\n        // Guards against the SDK being used in non-browser environments.\r\n        if (typeof window === 'undefined') {\r\n            throw ERROR_FACTORY.create(\"registration-window\" /* REGISTRATION_WINDOW */);\r\n        }\r\n        // Normalizes optional inputs.\r\n        var _a = app.options, projectId = _a.projectId, apiKey = _a.apiKey, appId = _a.appId;\r\n        if (!projectId) {\r\n            throw ERROR_FACTORY.create(\"registration-project-id\" /* REGISTRATION_PROJECT_ID */);\r\n        }\r\n        if (!apiKey) {\r\n            throw ERROR_FACTORY.create(\"registration-api-key\" /* REGISTRATION_API_KEY */);\r\n        }\r\n        if (!appId) {\r\n            throw ERROR_FACTORY.create(\"registration-app-id\" /* REGISTRATION_APP_ID */);\r\n        }\r\n        namespace = namespace || 'firebase';\r\n        var storage = new Storage(appId, app.name, namespace);\r\n        var storageCache = new StorageCache(storage);\r\n        var logger$1 = new logger.Logger(name);\r\n        // Sets ERROR as the default log level.\r\n        // See RemoteConfig#setLogLevel for corresponding normalization to ERROR log level.\r\n        logger$1.logLevel = logger.LogLevel.ERROR;\r\n        var restClient = new RestClient(installations, \r\n        // Uses the JS SDK version, by which the RC package version can be deduced, if necessary.\r\n        firebaseInstance.SDK_VERSION, namespace, projectId, apiKey, appId);\r\n        var retryingClient = new RetryingClient(restClient, storage);\r\n        var cachingClient = new CachingClient(retryingClient, storage, storageCache, logger$1);\r\n        var remoteConfigInstance = new RemoteConfig(app, cachingClient, storageCache, storage, logger$1);\r\n        // Starts warming cache.\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        remoteConfigInstance.ensureInitialized();\r\n        return remoteConfigInstance;\r\n    }\r\n}\r\nregisterRemoteConfig(firebase);\n\nexports.registerRemoteConfig = registerRemoteConfig;\n//# sourceMappingURL=index.cjs.js.map\n\n\n//# sourceURL=webpack:///./node_modules/@firebase/remote-config/dist/index.cjs.js?");

/***/ }),

/***/ "./node_modules/@firebase/remote-config/node_modules/tslib/tslib.es6.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@firebase/remote-config/node_modules/tslib/tslib.es6.js ***!
  \******************************************************************************/
/*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__extends\", function() { return __extends; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__assign\", function() { return __assign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__rest\", function() { return __rest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__decorate\", function() { return __decorate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__param\", function() { return __param; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__metadata\", function() { return __metadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__awaiter\", function() { return __awaiter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__generator\", function() { return __generator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__exportStar\", function() { return __exportStar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__values\", function() { return __values; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__read\", function() { return __read; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__spread\", function() { return __spread; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__spreadArrays\", function() { return __spreadArrays; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__await\", function() { return __await; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__asyncGenerator\", function() { return __asyncGenerator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__asyncDelegator\", function() { return __asyncDelegator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__asyncValues\", function() { return __asyncValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__makeTemplateObject\", function() { return __makeTemplateObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__importStar\", function() { return __importStar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__importDefault\", function() { return __importDefault; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__classPrivateFieldGet\", function() { return __classPrivateFieldGet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__classPrivateFieldSet\", function() { return __classPrivateFieldSet; });\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/@firebase/remote-config/node_modules/tslib/tslib.es6.js?");

/***/ }),

/***/ "./node_modules/firebase/remote-config/dist/index.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/firebase/remote-config/dist/index.esm.js ***!
  \***************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _firebase_remote_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/remote-config */ \"./node_modules/@firebase/remote-config/dist/index.cjs.js\");\n/* harmony import */ var _firebase_remote_config__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_firebase_remote_config__WEBPACK_IMPORTED_MODULE_0__);\n\n//# sourceMappingURL=index.esm.js.map\n\n\n//# sourceURL=webpack:///./node_modules/firebase/remote-config/dist/index.esm.js?");

/***/ })

}]);